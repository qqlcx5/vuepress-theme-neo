import{_ as e,c as o,o as d,a as t}from"./app-7eMFvEA8.js";const c={},i=t(`<h1 id="更新-移动端最佳适配解决方案" tabindex="-1"><a class="header-anchor" href="#更新-移动端最佳适配解决方案" aria-hidden="true">#</a> 更新！移动端最佳适配解决方案</h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>前段时间我的移动端适配解决方案<sup>[2]</sup>一文在评论区引发了激烈的讨论。其中讨论最多的就是，移动端rem的适配已经淘汰了，目前大家使用的都是<code>viewport</code>。<code>lib-flexible</code>作者也在github明确的表示<code>lib-flexible</code>这个解决方案可以放弃使用了。</p><blockquote><p>由于<code>viewport</code>单位得到众多浏览器的兼容，<code>lib-flexible</code>这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用<code>viewport</code>来替代此方案。</p></blockquote><p>看到大家的讨论,我受益匪浅。在这里也向那些阅读过我之前那篇移动端适配解决方案<sup>[3]</sup>文章的同行们说一声对不起。rem适配方案确实是已经淘汰了。</p><p>本文带大家一起来看看评论区所说的<code>viewport</code>适配解决方案。</p><h2 id="什么是viewport" tabindex="-1"><a class="header-anchor" href="#什么是viewport" aria-hidden="true">#</a> 什么是<code>viewport</code></h2><p><code>viewport</code>翻译成中文的意思大致是视图、视窗。在移动端设备中,整块显示屏就相当于视图、视窗。但这种说法也并不完全正确。因为在移动端设备中,浏览器视图并不是整个屏幕。因此<code>viewport</code>又被分为了3种 <code>layout viewport</code>、<code>visual viewport</code>、<code>ideal viewport</code></p><p>为了能够适配到pc端开发页面中,大部分浏览器把<code>viewport</code>的宽度设为了<code>980px</code> 这个浏览器默认设置的视图被称为 <code>layout viewport</code>。我们可以使用<code>document.documentElement.clientWidth</code> 来获取。</p><p>由于 <code>layout viewport</code>的宽度是远大于浏览器宽度的，因此我们需要一个新的<code>viewport</code>来代表浏览器的可视区域宽度，这个视图则被成为<code>visual viewport</code>我们可以使用<code>window.innerWidth</code>来获取。</p><p>现在我们已经有两个<code>viewport</code>了,<code>layout viewport</code> 和 <code>visual viewport</code>。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的<code>ideal viewport</code>。</p><p><code>ideal viewport</code> 并没有一个固定的尺寸，不同的设备拥有有不同的 <code>ideal viewport</code>。比如<code>iphone5</code>的 <code>ideal viewport</code>是 320px 而 <code>iphone6s</code>的 <code>ideal viewport</code>却是 375px</p><h2 id="viewport的单位vw、vh" tabindex="-1"><a class="header-anchor" href="#viewport的单位vw、vh" aria-hidden="true">#</a> <code>viewport</code>的单位<code>vw、vh</code></h2><p><code>vw、vh</code>将<code>viewport</code>分成了一百份。vw即 <code>viewport width</code> vh即<code>viewport height</code></p><ul><li><p>1vw等于视图单位的1%的宽度</p></li><li><p>1vh等于视图单位的1%的高度</p></li></ul><p>如果设计稿的视图为375px 那么1vw 等于 3.75px</p><p>在配置开始之前 我们依然需要一个vue-cli项目 在项目的<code>index.html</code> 我们需要在<code>head</code>标签中添加如下代码</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;&gt;复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="viewport适配解决方案" tabindex="-1"><a class="header-anchor" href="#viewport适配解决方案" aria-hidden="true">#</a> <code>viewport</code>适配解决方案</h2><p>之前的文章，我们用到了阿里巴巴手淘团队出品的<code>amfe-flexible</code>这个库。目的是为了获取到不同移动端设备下的像素比。对于<code>rem</code>的适配该库是至关重要的。本篇文章使用<code>viewport</code>适配则不再需要。</p><p>要使用<code>viewport</code>适配 我们必须安装<code>postcss-px-to-viewport</code>这个包。这包名是不是有一种似曾相识的感觉。</p><p>没错,上篇文章中我们使用过<code>postcss-pxtorem</code>。这两个包不仅名字相似，功能也有相似的地方。<code>postcss-pxtorem</code>是将 <code>px</code>单位转换为<code>rem</code>单位。<code>postcss-px-to-viewport</code>则是将px单位转换为<code>vw、vh</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//引入 postcss-px-to-viewport npm install postcss-px-to-viewport --save-dev复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装完成后 我们需要进行<code>postcss</code>插件相关的配置 在根目录新建一个名为<code>postcss.config.js</code>的文件,如果项目中已包含该文件则无需新建。在文件中写入如下代码:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//postcss.config.jsmodule.exports = {  plugins: {    &#39;postcss-px-to-viewport&#39;: {     unitToConvert: &quot;px&quot;, // 要转化的单位            viewportWidth: 375, // UI设计稿的宽度            unitPrecision: 6, // 转换后的精度，即小数点位数            propList: [&quot;*&quot;], // 指定转换的css属性的单位，*代表全部css属性的单位都进行转换          viewportUnit: &quot;vw&quot;, // 指定需要转换成的视窗单位，默认vw            fontViewportUnit: &quot;vw&quot;, // 指定字体需要转换成的视窗单位，默认vw      selectorBlackList: [&quot;wrap&quot;], // 指定不转换为视窗单位的类名，            minPixelValue: 1, // 默认值1，小于或等于1px则不进行转换            mediaQuery: true, // 是否在媒体查询的css代码中也进行转换，默认false           replace: true, // 是否转换后直接更换属性值            exclude: [/node_modules/], // 设置忽略文件，用正则做目录名匹配           }  }}复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在配置上这两个包也有相似的功能。大家可以去参考一下<code>postcss-px-to-viewport</code>作者的github<sup>[4]</sup></p><p><strong>值得注意的是:<code>postcss-px-to-viewport</code> 同样存在第三方组件库兼容性的问题。比如在设计稿为750px时使用vant组件库会将vant组件的样式缩小。</strong></p><h2 id="解决第三方组件库兼容问题" tabindex="-1"><a class="header-anchor" href="#解决第三方组件库兼容问题" aria-hidden="true">#</a> 解决第三方组件库兼容问题</h2><p>vant组件库的设计稿是按照375px来开发的。因此在<code>viewportWidth</code>为<code>750px</code>时会出现转换问题。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// postcss.config.jsconst path = require(&#39;path&#39;);module.exports = ({ webpack }) =&gt; {  const viewWidth = webpack.resourcePath.includes(path.join(&#39;node_modules&#39;, &#39;vant&#39;)) ? 375 : 750;  return {    plugins: {      autoprefixer: {},      &quot;postcss-px-to-viewport&quot;: {        unitToConvert: &quot;px&quot;,        viewportWidth: viewWidth,        unitPrecision: 6,        propList: [&quot;*&quot;],        viewportUnit: &quot;vw&quot;,        fontViewportUnit: &quot;vw&quot;,        selectorBlackList: [],        minPixelValue: 1,        mediaQuery: true,        exclude: [],        landscape: false      }    }  }}复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果读取的<code>node_modules</code>中的文件是<code>vant</code>,那么就将设计稿变为375px。如果读取的文件不是<code>vant</code>的文件,那么就将设计稿变为750px。这样就可以避免<code>vant</code>组件在750px下出现样式缩小的问题了。</p><p>同理 这对于其他的移动端UI组件库同样有效果。我们只需要改动这行代码即可</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const viewWidth = webpack.resourcePath.includes(path.join(&#39;node_modules&#39;, &#39;vant&#39;)) ? 375 : 750; 复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>至此，我们的viewport的适配就做好了，只需要按照设计稿的比例进行开发就可以了。</p>`,34),p=[i];function a(s,r){return d(),o("div",null,p)}const l=e(c,[["render",a],["__file","移动端最佳适配解决方案.html.vue"]]);export{l as default};
